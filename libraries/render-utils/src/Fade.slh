//  Generated on <$_SCRIBE_DATE$>
//
//  Created by Olivier Prat on 04/12/17.
//  Copyright 2017 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
//
<@if not FADE_SLH@>
<@def FADE_SLH@>

<@include render-utils/ShaderConstants.h@>

<@func declareFadeFragmentCommon()@>

<@include FadeObjectParams.shared.slh@>

LAYOUT(binding=RENDER_UTILS_TEXTURE_FADE_MASK) uniform sampler2D fadeMaskMap;

vec2 hash2D(vec3 position) {
    return position.xy* vec2(0.1677,  0.221765) + position.z*0.561;
}

float noise3D(vec3 position) {
    float n = textureLod(fadeMaskMap, hash2D(position), 0.0).r;
    return pow(n, 1.0/2.2); // Remove sRGB. Need to fix this later directly in the texture
}

float evalFadeNoiseGradient(FadeObjectParams params, vec3 position) {
    // Do tri-linear interpolation
    vec3    noisePosition = position * params.noiseInvSizeAndLevel.xyz + params.noiseOffsetAndInverted.xyz;
    vec3    noisePositionFloored = floor(noisePosition);
    vec3    noisePositionFraction = fract(noisePosition);

    noisePositionFraction = noisePositionFraction*noisePositionFraction*(3.0 - 2.0*noisePositionFraction);

    float   noiseLowXLowYLowZ = noise3D(noisePositionFloored);
    float   noiseLowXHighYLowZ = noise3D(noisePositionFloored+vec3(0,1,0));
    float   noiseHighXLowYLowZ = noise3D(noisePositionFloored+vec3(1,0,0));
    float   noiseHighXHighYLowZ = noise3D(noisePositionFloored+vec3(1,1,0));
    float   noiseLowXLowYHighZ = noise3D(noisePositionFloored+vec3(0,0,1));
    float   noiseLowXHighYHighZ = noise3D(noisePositionFloored+vec3(0,1,1));
    float   noiseHighXLowYHighZ = noise3D(noisePositionFloored+vec3(1,0,1));
    float   noiseHighXHighYHighZ = noise3D(noisePositionFloored+vec3(1,1,1));
    vec4    maskLowZ = vec4(noiseLowXLowYLowZ, noiseLowXHighYLowZ, noiseHighXLowYLowZ, noiseHighXHighYLowZ);
    vec4    maskHighZ = vec4(noiseLowXLowYHighZ, noiseLowXHighYHighZ, noiseHighXLowYHighZ, noiseHighXHighYHighZ);
    vec4    maskXY = mix(maskLowZ, maskHighZ, noisePositionFraction.z);
    vec2    maskY = mix(maskXY.xy, maskXY.zw, noisePositionFraction.x);

    float noise = mix(maskY.x, maskY.y, noisePositionFraction.y);
    noise -= 0.5;   // Center on value 0
    return noise * params.noiseInvSizeAndLevel.w;
}

float evalFadeBaseGradient(FadeObjectParams params, vec3 position) {
    float gradient = length((position - params.baseOffsetAndThreshold.xyz) * params.baseInvSizeAndLevel.xyz);
    gradient = gradient-0.5;  // Center on value 0.5
    gradient *= params.baseInvSizeAndLevel.w;
    return gradient;
}

float evalFadeGradient(FadeObjectParams params, vec3 position) {
    float baseGradient = evalFadeBaseGradient(params, position);
    float noiseGradient = evalFadeNoiseGradient(params, position);
    float gradient = noiseGradient+baseGradient+0.5;

    return gradient;
}

float evalFadeAlpha(FadeObjectParams params, vec3 position) {
    float alpha = evalFadeGradient(params, position) - params.baseOffsetAndThreshold.w;
    alpha *= 1.0 - 2.0 * params.noiseOffsetAndInverted.w;
    return alpha;
}

void applyFadeClip(FadeObjectParams params, vec3 position) {
    if (evalFadeAlpha(params, position) < 0.0) {
        discard;
    }
}

void applyFade(FadeObjectParams params, vec3 position, out vec3 emissive) {
    float alpha = evalFadeAlpha(params, position);

    if (alpha < 0.0) {
        discard;
    }
    
    float edgeMask = alpha * params.edgeWidthInv;
    float edgeAlpha = 1.0-clamp(edgeMask, 0.0, 1.0);

    edgeMask = step(edgeMask, 1.0);
    edgeAlpha *= edgeAlpha; // Square to have a nice ease out
    vec4 color = mix(params.innerEdgeColor, params.outerEdgeColor, edgeAlpha);
    emissive = color.rgb * edgeMask * color.a;
}

<@endfunc@>

<@func declareFadeFragmentUniform()@>

LAYOUT_STD140(binding=RENDER_UTILS_BUFFER_FADE_OBJECT_PARAMS) uniform fadeObjectParametersBuffer {
    FadeObjectParams fadeObjectParams;
};

<@endfunc@>

<@func fetchFadeObjectParams(fadeParams)@>
    <$fadeParams$> = fadeObjectParams;
<@endfunc@>

<@func declareFadeFragmentVertexInput()@>

layout(location=RENDER_UTILS_ATTR_FADE1) flat in vec4 _fadeData1;
layout(location=RENDER_UTILS_ATTR_FADE2) flat in vec4 _fadeData2;
layout(location=RENDER_UTILS_ATTR_FADE3) flat in vec4 _fadeData3;
layout(location=RENDER_UTILS_ATTR_FADE4) flat in vec4 _fadeData4;
layout(location=RENDER_UTILS_ATTR_FADE5) flat in vec4 _fadeData5;
layout(location=RENDER_UTILS_ATTR_FADE6) flat in vec4 _fadeData6;
layout(location=RENDER_UTILS_ATTR_FADE7) flat in float _fadeData7;

<@endfunc@>

<@func fetchFadeObjectParamsInstanced(fadeParams)@>
    <$fadeParams$>.noiseOffsetAndInverted = _fadeData1;
    <$fadeParams$>.baseOffsetAndThreshold = _fadeData2;
    <$fadeParams$>.baseInvSizeAndLevel = _fadeData3;
    <$fadeParams$>.noiseInvSizeAndLevel = _fadeData4;
    <$fadeParams$>.innerEdgeColor = _fadeData5;
    <$fadeParams$>.outerEdgeColor = _fadeData6;
    <$fadeParams$>.edgeWidthInv = _fadeData7;
<@endfunc@>

<@func declareFadeFragment()@>
<$declareFadeFragmentCommon()$>
<$declareFadeFragmentUniform()$>
<@endfunc@>

<@func declareFadeFragmentInstanced()@>
<$declareFadeFragmentCommon()$>
<$declareFadeFragmentVertexInput()$>
<@endfunc@>

<@func declareFadeVertexInstanced()@>
layout(location=GPU_ATTR_FADEDATA1) in vec4 fadeData1;
layout(location=GPU_ATTR_FADEDATA2) in vec4 fadeData2;
layout(location=GPU_ATTR_FADEDATA3) in vec4 fadeData3;
layout(location=GPU_ATTR_FADEDATA4) in vec4 fadeData4;
layout(location=GPU_ATTR_FADEDATA5) in vec4 fadeData5;
layout(location=GPU_ATTR_FADEDATA6) in vec4 fadeData6;
layout(location=GPU_ATTR_FADEDATA7) in float fadeData7;

layout(location=RENDER_UTILS_ATTR_FADE1) flat out vec4 _fadeData1;
layout(location=RENDER_UTILS_ATTR_FADE2) flat out vec4 _fadeData2;
layout(location=RENDER_UTILS_ATTR_FADE3) flat out vec4 _fadeData3;
layout(location=RENDER_UTILS_ATTR_FADE4) flat out vec4 _fadeData4;
layout(location=RENDER_UTILS_ATTR_FADE5) flat out vec4 _fadeData5;
layout(location=RENDER_UTILS_ATTR_FADE6) flat out vec4 _fadeData6;
layout(location=RENDER_UTILS_ATTR_FADE7) flat out float _fadeData7;
<@endfunc@>

<@func passThroughFadeObjectParams()@>
    _fadeData1 = fadeData1;
    _fadeData2 = fadeData2;
    _fadeData3 = fadeData3;
    _fadeData4 = fadeData4;
    _fadeData5 = fadeData5;
    _fadeData6 = fadeData6;
    _fadeData7 = fadeData7;
<@endfunc@>

<@endif@>
