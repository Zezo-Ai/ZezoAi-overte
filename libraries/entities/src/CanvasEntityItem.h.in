//
//  Created by Ada <ada@thingvellir.net> on 2025-02-04
//  Copyright 2025 Overte e.V.
//
//  Distributed under the Apache license, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html

#ifndef hifi_CanvasEntityItem_h
#define hifi_CanvasEntityItem_h

#include "EntityItem.h"
#include <CanvasCommand.h>
#include <mutex>

class CanvasEntityItem : public EntityItem {
public:
    static EntityItemPointer factory(const EntityItemID& entityID, const EntityItemProperties& properties);

    CanvasEntityItem(const EntityItemID& entityItemID);
    ~CanvasEntityItem();

    virtual ShapeType getShapeType() const override { return SHAPE_TYPE_BOX; }

    ALLOW_INSTANTIATION // This class can be instantiated
    ENTITY_PROPERTY_SUBCLASS_METHODS

    const QByteArray& getImageData() const {
        const std::lock_guard<std::recursive_mutex> dataLock(_imageDataMutex);
        return _imageData;
    }

    void setImageData(const CanvasImage& image);

    void pushCommands(const QVector<CanvasCommand>& queue) {
        const std::lock_guard<std::recursive_mutex> commandQueueLock(_commandQueueMutex);
        _commandQueue.append(queue);
    }

    void commit();

    std::atomic<bool> _imageDataDirty;
    mutable std::recursive_mutex _imageDataMutex;

protected:
@Canvas_ENTITY_PROPS@

    int expectedSize() const;
    void updateBufferSize();
    void paintCommands(const QVector<CanvasCommand>& queue);

    QByteArray _imageData;

    std::recursive_mutex _commandQueueMutex;
    QVector<CanvasCommand> _commandQueue;
};

#endif // hifi_CanvasEntityItem_h
